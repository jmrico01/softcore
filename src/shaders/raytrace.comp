#version 450

#define MAX_MATERIALS 32

#define EPSILON 0.000001
#define BOUNCES 4
#define MIN_DIST 0.01
#define MAX_DIST 20.0

struct Material
{
	vec3 albedo;
	float smoothness;
	vec3 emissionColor;
	float emission;
};

struct Triangle
{
	vec3 a, b, c;
	vec3 normal;
	uint materialIndex;
};

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D resultImage;
layout(binding = 1) uniform UBO
{
	vec3 cameraPos;
	vec3 filmTopLeft;
	vec3 filmUnitOffsetX;
	vec3 filmUnitOffsetY;
	Material materials[MAX_MATERIALS];
} ubo;
layout(std140, binding = 2) buffer Triangles
{
	Triangle triangles[];
};

vec3 RaycastColor(vec3 rayOrigin, vec3 rayDir)
{
	float intensity = 1.0;
	vec3 color = vec3(0.0, 0.0, 0.0);

	for (uint i = 0; i < BOUNCES; i++) {
		uint hitMaterialIndex = MAX_MATERIALS;
		vec3 hitNormal;
		float hitDist = MAX_DIST;

		for (uint j = 0; j < triangles.length(); j++) {
			vec3 triangleNormal = triangles[j].normal;
			float dotNegRayNormal = dot(rayDir, triangleNormal);
			if (dotNegRayNormal > 0.0) {
				continue;
			}

			vec3 a = triangles[j].a;
			vec3 b = triangles[j].b;
			vec3 c = triangles[j].c;

			// ray-triangle intersection
			vec3 ab = b - a;
			vec3 ac = c - a;
			vec3 h = cross(rayDir, ac);
			float x = dot(ab, h);
			if (x > -EPSILON && x < EPSILON) {
				continue;
			}

			float f = 1.0 / x;
			vec3 s = rayOrigin - a;
			float u = f * dot(s, h);
			if (u < 0.0 || u > 1.0) {
				continue;
			}

			vec3 q = cross(s, ab);
			float v = f * dot(rayDir, q);
			if (v < 0.0f || u + v > 1.0) {
				continue;
			}

			float t = f * dot(ac, q);
			if (t > MIN_DIST && t < hitDist) {
				return vec3(1.0, 0.0, 1.0);
				hitMaterialIndex = triangles[j].materialIndex;
				hitNormal = triangleNormal;
				hitDist = t;
			}
		}

		if (hitMaterialIndex != MAX_MATERIALS) {
			Material hitMaterial = ubo.materials[hitMaterialIndex];
			if (hitMaterial.emission > 0.0) {
				color = hitMaterial.emission * hitMaterial.emissionColor * intensity;
				break;
			}
			else {
				intensity *= 0.5f;
				rayOrigin += rayDir * hitDist;
				vec3 pureBounce = rayDir - 2.0f * dot(rayDir, hitNormal) * hitNormal;
				rayDir = pureBounce;
			}
		}
	}

	return color;
}

void main()
{
	uvec2 pixel = gl_GlobalInvocationID.xy;
	vec3 filmOffsetX = ubo.filmUnitOffsetX * pixel.x;
	vec3 filmOffsetY = ubo.filmUnitOffsetY * pixel.y;
	vec3 filmPos = ubo.filmTopLeft + filmOffsetX + filmOffsetY;
	vec3 rayDir = normalize(filmPos - ubo.cameraPos);

	vec4 color = vec4(RaycastColor(ubo.cameraPos, rayDir), 1.0);
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), color);
}
