#version 450

#define TILE_SIZE 16
#define MAX_MATERIALS 32

#define EPSILON 0.000001
#define BOUNCES 4
#define MIN_DIST 0.01
#define MAX_DIST 20.0

#define QUAT_ONE vec4(0.0, 0.0, 0.0, 1.0)

struct Material
{
	vec3 albedo;
	float smoothness;
	vec3 emissionColor;
	float emission;
};

struct Triangle
{
	vec3 a, b, c;
	vec3 normal;
	uint materialIndex;
};

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;

layout(binding = 0, rgba8) uniform writeonly image2D resultImage;
layout(binding = 1) uniform UBO
{
	vec3 cameraPos;
	vec3 filmTopLeft;
	vec3 filmUnitOffsetX;
	vec3 filmUnitOffsetY;
	Material materials[MAX_MATERIALS];
} ubo;
layout(std140, binding = 2) buffer Triangles
{
	Triangle triangles[];
};

const uint UINT32_MAX_VALUE = 0xffffffff;

// Reference https://en.wikipedia.org/wiki/Xorshift
uint XOrShift32(uint value)
{
	value ^= value << 13;
	value ^= value >> 17;
	value ^= value << 5;
	return value;
}

uint RandomUInt(inout uint state)
{
	state = XOrShift32(state);
	return state;
}

float RandomUnilateral(inout uint state)
{
	return float(RandomUInt(state)) / float(UINT32_MAX_VALUE);
}

float RandomBilateral(inout uint state)
{
	return 2.0 * RandomUnilateral(state) - 1.0;
}

vec4 QuatMultiply(vec4 q1, vec4 q2)
{
    vec4 result;
    result.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y;
    result.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z;
    result.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;
    result.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;
    return result;
}

vec4 QuatInverse(vec4 q)
{
	return vec4(-q.x, -q.y, -q.z, q.w);
}

vec3 QuatRotate(vec3 v, vec4 quat)
{
	// TODO Quat multiply with baked w=0
	vec4 vQuat = vec4(v, 0.0);

	vec4 qv = QuatMultiply(quat, vQuat);
	vec4 qInv = QuatInverse(quat);
	vec4 qvqInv = QuatMultiply(qv, qInv);

	return vec3(qvqInv.x, qvqInv.y, qvqInv.z);
}

vec4 QuatFromAngleUnitAxis(float angle, vec3 axis)
{
	float cosHalfAngle = cos(angle / 2.0);
	float sinHalfAngle = sin(angle / 2.0);

	return vec4(axis.x * sinHalfAngle, axis.y * sinHalfAngle, axis.z * sinHalfAngle, cosHalfAngle);
}

// Returns a quaternion for the rotation required to align unit X vector with unit vector reference
vec4 QuatRotationFromUnitX(vec3 reference)
{
	float dotRefUnitX = dot(vec3(1.0, 0.0, 0.0), reference);
	if (dotRefUnitX > 0.99999f) {
		return QUAT_ONE;
	}
	else if (dotRefUnitX < -0.99999f) {
		// 180-degree rotation about y axis (perpendicular to x)
		// comptime angle = PI, cosHalfAngle = 0, sinHalfAngle = 1, axis = 0.0, 1.0, 0.0
		return vec4(0.0, 1.0, 0.0, 0.0);
	}

	float angle = 1.0 + dotRefUnitX;
	vec3 unitAxis = normalize(cross(vec3(1.0, 0.0, 0.0), reference));
	return QuatFromAngleUnitAxis(angle, unitAxis);
}

vec3 RaycastColor(vec3 rayOrigin, vec3 rayDir, uint randomSeed)
{
	uint randomState = randomSeed;

	float intensity = 1.0;
	vec3 color = vec3(0.0, 0.0, 0.0);

	for (uint i = 0; i < BOUNCES; i++) {
		uint hitMaterialIndex = MAX_MATERIALS;
		vec3 hitNormal;
		float hitDist = MAX_DIST;

		for (uint j = 0; j < triangles.length(); j++) {
			vec3 normal = triangles[j].normal;
			float dotNegRayNormal = dot(rayDir, normal);
			if (dotNegRayNormal > 0.0) {
				continue;
			}

			vec3 a = triangles[j].a;
			vec3 b = triangles[j].b;
			vec3 c = triangles[j].c;

			// ray-triangle intersection
			vec3 ab = b - a;
			vec3 ac = c - a;
			vec3 h = cross(rayDir, ac);
			float x = dot(ab, h);
			if (x > -EPSILON && x < EPSILON) {
				continue;
			}

			float f = 1.0 / x;
			vec3 s = rayOrigin - a;
			float u = f * dot(s, h);
			if (u < 0.0 || u > 1.0) {
				continue;
			}

			vec3 q = cross(s, ab);
			float v = f * dot(rayDir, q);
			if (v < 0.0f || u + v > 1.0) {
				continue;
			}

			float t = f * dot(ac, q);
			if (t > MIN_DIST && t < hitDist) {
				hitMaterialIndex = triangles[j].materialIndex;
				hitNormal = normal;
				hitDist = t;
			}
		}

		if (hitMaterialIndex != MAX_MATERIALS) {
			Material hitMaterial = ubo.materials[hitMaterialIndex];
			if (hitMaterial.emission > 0.0) {
				color = hitMaterial.emission * hitMaterial.emissionColor * intensity;
				break;
			}
			else {
				intensity *= 0.5f;
				rayOrigin += rayDir * hitDist;

				vec3 pureBounce = rayDir - 2.0f * dot(rayDir, hitNormal) * hitNormal;
				vec3 randomHemisphereUnitX = normalize(vec3(
					RandomUnilateral(randomState),
					RandomBilateral(randomState),
					RandomBilateral(randomState)
				));
				vec4 quatXToNormal = QuatRotationFromUnitX(hitNormal);
				vec3 randomBounce = QuatRotate(randomHemisphereUnitX, quatXToNormal);

				rayDir = normalize(mix(randomBounce, pureBounce, hitMaterial.smoothness));
			}
		}
	}

	return color;
}

void main()
{
	uvec2 pixel = gl_GlobalInvocationID.xy;
	vec3 filmOffsetX = ubo.filmUnitOffsetX * pixel.x;
	vec3 filmOffsetY = ubo.filmUnitOffsetY * pixel.y;
	vec3 filmPos = ubo.filmTopLeft + filmOffsetX + filmOffsetY;
	vec3 rayDir = normalize(filmPos - ubo.cameraPos);

	uint seed = pixel.x * 53829 + pixel.y * 17;
	vec3 raycastColor = RaycastColor(ubo.cameraPos, rayDir, seed);

	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(raycastColor, 1.0));
}
